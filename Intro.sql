--CREATE DATABASE TRAINING;  
--USE TRAINING;
DECLARE @CNAME CHAR(20)
DECLARE @VNAME VARCHAR(20)
SET @CNAME = 'JOHN'
SET @VNAME = 'JOHN'
PRINT DATALENGTH(@CNAME)
PRINT DATALENGTH(@VNAME)

SELECT GETDATE()

CREATE TABLE DEPARTMENT (
	DEPTNO NUMERIC(3) NOT NULL PRIMARY KEY,
	DEPTNAME VARCHAR(10) NOT NULL UNIQUE
)

CREATE TABLE EMPLOYEE(
	EMPNO NUMERIC(4) IDENTITY(1,1) NOT NULL PRIMARY KEY,
	EMPNAME VARCHAR(20) NOT NULL,
	DESIG VARCHAR(20) NULL CHECK(DESIG IN ('CEO', 'MANAGER', 'DEVELOPER')),
	HIREDATE DATETIME NULL DEFAULT GETDATE(),
	MGR NUMERIC(4) NULL REFERENCES EMPLOYEE(EMPNO),
	SALARY NUMERIC(10,2) NULL CHECK (SALARY >= 5000),
	DEPTNO NUMERIC(3) NULL REFERENCES DEPARTMENT(DEPTNO)
)

select * from DEPARTMENT
select * from EMPLOYEE

SP_HELP 'DEPARTMENT'
SP_HELP 'EMPLOYEE'

INSERT INTO DEPARTMENT VALUES(10, 'HR')
INSERT INTO DEPARTMENT VALUES(20, 'SALES')

INSERT INTO EMPLOYEE VALUES('JOHN', 'CEO', '06/14/2001', NULL, 40000,NULL)
INSERT INTO EMPLOYEE VALUES('CHANDLER', 'MANAGER', 4, NULL, 30000,10)
INSERT INTO EMPLOYEE (EMPNAME, DEPTNO) VALUES('AMIT',20)
INSERT INTO EMPLOYEE(EMPNAME, DEPTNO, HIREDATE) VALUES('PRIYA',	20, NULL)

UPDATE EMPLOYEE SET DESIG='DEVELOPER', SALARY=100000 WHERE EMPNO=3

-- priya joinING AS A DEVELOPER ON 01 JUNE 2021 AND HER SALARY IS 125000
UPDATE EMPLOYEE SET DESIG='DEVELOPER', SALARY=125000, HIREDATE='06/01/2021' WHERE EMPNO=4

DELETE FROM EMPLOYEE WHERE EMPNO=3

--CREATE TABLE TESTDATA(
--	TESTNO INT PRIMARY KEY IDENTITY(1,1)
--)
--INSERT INTO TESTDATA VALUES()

--CREATE TABLE COUNTRY(
--	COUNTRYID VARCHAR(3) PRIMARY KEY,
--	COUNTRYNAME VARCHAR(20) UNIQUE,
--	CAPITAL VARCHAR(20),
--	FLAG	VARBINARY(MAX)
--)

--CREATE TABLE STATE(
--	STATEID	VARCHAR(3) PRIMARY KEY,
--	STATENAME	VARCHAR(20),
--	STATECAPITAL VARCHAR(20),
--	COUNTRYID	VARCHAR(3) REFERENCES
--)
-- INSERT MINIMUM 2 RECORDS IN BOTH TABLES

ALTER TABLE EMPLOYEE ADD GENDER CHAR(1) NULL
UPDATE EMPLOYEE SET GENDER='F' WHERE EMPNO=4


-- ALTER TABLE EMPLOYEE ADD GENDER CHAR(1) NOT NULL DEFAULT='M'
-- DROP TABLE EMPLOYEE

SELECT * FROM DEPARTMENT
SELECT * FROM EMPLOYEE

-- FROM DEPARTMENT TABLE DELETE DEPTNO 20
DELETE FROM	DEPARTMENT WHERE DEPTNO=20

ALTER TABLE EMPLOYEE DROP CONSTRAINT FK__EMPLOYEE__DEPTNO__2A4B4B5E
ALTER TABLE EMPLOYEE ADD CONSTRAINT FK__EMPLOYEE__DEPTNO FOREIGN KEY (DEPTNO)
REFERENCES DEPARTMENT (DEPTNO) ON DELETE CASCADE
INSERT INTO EMPLOYEE (EMPNAME, DEPTNO) VALUES('ROSS', 20)
INSERT INTO EMPLOYEE (EMPNAME, DEPTNO) VALUES('MONICA', 20)
INSERT INTO EMPLOYEE (EMPNAME, DEPTNO) VALUES('JOEY', 10)
INSERT INTO EMPLOYEE (EMPNAME, DEPTNO) VALUES('AYAAN', 10)
INSERT INTO EMPLOYEE (EMPNAME, DEPTNO) VALUES('RAHUL', 10)
DELETE FROM DEPARTMENT WHERE DEPTNO=20

SELECT * FROM DEPARTMENT
SELECT * FROM EMPLOYEE

ALTER TABLE EMPLOYEE DROP CONSTRAINT FK__EMPLOYEE__DEPTNO
ALTER TABLE EMPLOYEE ADD CONSTRAINT FK__EMPLOYEE__DEPTNO FOREIGN KEY (DEPTNO)
REFERENCES DEPARTMENT (DEPTNO) ON DELETE SET NULL

SP_HELP 'EMPLOYEE'
DELETE FROM DEPARTMENT WHERE DEPTNO=10
SELECT * FROM DEPARTMENT
SELECT * FROM EMPLOYEE

ALTER TABLE EMPLOYEE DROP CONSTRAINT FK__EMPLOYEE__DEPTNO
ALTER TABLE EMPLOYEE ADD CONSTRAINT FK__EMPLOYEE__DEPTNO FOREIGN KEY (DEPTNO)
REFERENCES DEPARTMENT (DEPTNO) ON DELETE SET NULL ON UPDATE CASCADE

UPDATE DEPARTMENT SET DEPTNO=20 WHERE DEPTNO=10

CREATE TABLE PROJECT (
	PROJID INT NOT NULL PRIMARY KEY,
	PROJNAME VARCHAR(20) UNIQUE
)

CREATE TABLE EMP_PROJECT_DETAIL (
	EMPNO NUMERIC(4) NOT NULL REFERENCES EMPLOYEE(EMPNO),
	PROJID INT NOT NULL REFERENCES PROJECT(PROJID),
	HOURS INT,
	RATE NUMERIC(10,2),
	PRIMARY KEY(EMPNO, PROJID)  -- TABLE LEVEL CONSTRAINT  (composite key)
)

sp_help 'EMP_PROJECT_DETAIL'

-------------------------------
CREATE SCHEMA HR;


CREATE TABLE DEPT
       (DEPTNO int not null constraint DEPT_deptno_pk1 primary key,
        DNAME VARCHAR(14) CONSTRAINT DEPT_Dname_UNQ UNIQUE,
        LOC VARCHAR(13) )

INSERT INTO DEPT VALUES (10, 'ACCOUNTING', 'NEW YORK');
INSERT INTO DEPT VALUES (20, 'RESEARCH',   'NEW YORK');
INSERT INTO DEPT VALUES (30, 'SALES',      'BOSTON');
INSERT INTO DEPT VALUES (40, 'OPERATIONS', 'BOSTON');


CREATE TABLE EMP
       (EMPNO int NOT NULL CONSTRAINT EMP_EMPNO_PK PRIMARY KEY,
        ENAME VARCHAR(30),
        JOB VARCHAR(9),
        MGR int CONSTRAINT EMP_MGR_SK REFERENCES EMP(EMPNO),
        HIREDATE DATETIME,
        SAL NUmeric(7, 2),
        COMM Numeric(7, 2),
        DEPTNO int CONSTRAINT EMP_DEPTNO_FK REFERENCES DEPT(DEPTNO))

INSERT INTO EMP VALUES
        (7839, 'KING',   'PRESIDENT', NULL, '11/17/1981' , 5000, NULL, null)
INSERT INTO EMP VALUES
        (7566, 'JONES',  'MANAGER',   7839, '04/2/1981',  2975, NULL, 20)
INSERT INTO EMP VALUES
        (7698, 'BLAKE',  'MANAGER',   7839,'05/01/1985',  2975, NULL, 30)
INSERT INTO EMP VALUES
        (7782, 'CLARK',  'MANAGER',   7839, '06/09/1985',  2450, NULL, 10)
INSERT INTO EMP VALUES
        (7999, 'JOHN_MILLER', 'MANAGER',  7839, '01/01/2011' , 4000, NULL, 10)
INSERT INTO EMP VALUES
        (7788, 'SCOTT',  'ANALYST',   7566, '12/09/1982' , 3000, NULL, 20)
INSERT INTO EMP VALUES
        (7902, 'FORD',   'ANALYST',   7566, '12/03/1981' ,  3000, NULL, 20)
INSERT INTO EMP VALUES
        (7499, 'ALLEN',  'SALESMAN',  7698,'02/20/1985', 1600,  300, 30)
INSERT INTO EMP VALUES
        (7521, 'WARD',   'SALESMAN',  7698, '02/22/1981', 1250,  500, 30)
INSERT INTO EMP VALUES
        (7654, 'MARTIN', 'SALESMAN',  7698, '09/28/1991', 1250, 1400, 30)
INSERT INTO EMP VALUES
        (7844, 'TURNER', 'SALESMAN',  7698, '09/08/1985' ,  1500,    0, 30)
INSERT INTO EMP VALUES
        (7900, 'JAMES',  'CLERK',     7698, '12/03/1981' ,   950, NULL, 30)
INSERT INTO EMP VALUES
        (7369, 'SMITH',  'CLERK',     7902, '12/17/1980', 800, NULL, 20)
INSERT INTO EMP VALUES
        (7876, 'ADAMS',  'CLERK',     7788, ' 01/12/2003', 1100, NULL, 20)
INSERT INTO EMP VALUES
        (7934, 'MILLER', 'CLERK',     7782, '01/23/2003' , 1300, NULL, 10)

SELECT * FROM DEPT;
SELECT * FROM EMP;

-- column alias
SELECT EMPNO, ENAME AS [EMP NAME], JOB JOBB, SAL AS SALARY FROM EMP

-- FILTER -WHERE
-- EMPLOYEES WITH DEPT 30
SELECT * FROM EMP WHERE DEPTNO=30;

-- Day 2
SELECT * FROM EMP WHERE DEPTNO=20 AND SAL>2500
SELECT * FROM EMP WHERE JOB IN ('MANAGER', 'CLERK', 'ANALYST')
SELECT * FROM EMP WHERE (DEPTNO=10 AND JOB='CLERK') OR (DEPTNO=30 AND JOB='MANAGER')
SELECT * FROM EMP WHERE SAL>=3000 AND SAL<=5000
SELECT * FROM EMP WHERE COMM>(0.5*SAL)
SELECT * FROM EMP WHERE COMM IS NOT NULL


-- all emp whose name start with J
SELECT * FROM EMP WHERE ENAME LIKE 'J%'
-- ALL EMP WHOSE NAME CONTAINS 'A' AS A SECOND CHAR
SELECT * FROM EMP WHERE ENAME LIKE '_A%'

--1	LIST ALL EMPS WHOSE NAME ENDS WITH N
SELECT * FROM EMP WHERE ENAME LIKE '%N'

--2	LIST ALL EMP WHOSE NAME CONTAINS I
SELECT * FROM EMP WHERE ENAME LIKE '%I%'

--3	LIST ALL EMP WHOSE NAME START WITH A OR M OR S
SELECT * FROM EMP WHERE ENAME LIKE '[AMS]%'

--4	LIST ALL EMP WHOSE NAME START WITH A...M  (A,B,C,...M)
SELECT * FROM EMP WHERE ENAME LIKE '[A-M]%'

--5	LIST ALL EMP WHOSE NAME DOES NOT START WITH J OR W
SELECT * FROM EMP WHERE ENAME NOT LIKE '[JW]%'

--6	list all emp whose name contains vowel o or u or e, either at 2 position or at second last position
--ENAME LIKE '_[OUE]%' OR ENAME LIKE '%[OUE]_'
SELECT * FROM EMP WHERE ENAME LIKE '_[OUE]%[OUE]_'

--7	LIST ALL EMP WHOSE NAME CONTAINS _   (ANS IS JOHN_MILLER)
SELECT * FROM EMP WHERE ENAME LIKE '%\_%' ESCAPE '\'   -- oracle way but running 
SELECT * FROM EMP WHERE ENAME LIKE '%[_]%' -- ms sql way

-- SORTING - ORDER BY
SELECT * FROM EMP ORDER BY ENAME
SELECT * FROM EMP ORDER BY ENAME DESC

-- LIST ALL EMP AS PER THE JOB
SELECT * FROM EMP ORDER BY JOB

-- LIST ALL EMP AS PER THE 

-- multi column SORT
-- WITHIN DEPTNO SORT ON SAL H TO L
SELECT * FROM EMP ORDER BY DEPTNO, SAL DESC

-- LIST ALL EMP NAME, JOB, SAL , COMM
-- ADD A COLUMN NAME AT AS NETSAL (SAL+COMM)
-- SORT BY NETSL H TO L
SELECT ENAME, JOB, SAL, COMM, NETSAL=SAL+COMM FROM EMP
SELECT ENAME, JOB, SAL, COMM, ISNULL(SAL,0)+ISNULL(COMM ,0) AS NETSAL FROM EMP WHERE ISNULL(SAL,0)+ISNULL(COMM ,0)>2500 ORDER BY NETSAL DESC;
SELECT * FROM (SELECT ENAME, JOB, SAL, COMM, ISNULL(SAL,0)+ISNULL(COMM ,0) AS NETSAL FROM EMP) AS TMP
WHERE NETSAL > 2500 ORDER BY NETSAL DESC

-- AGGREGATE FUNCTIONS
SELECT SUM(SAL), AVG(SAL), MIN(SAL), MAX(SAL), COUNT(*) AS [*], COUNT(EMPNO) AS PRMARYKEY, COUNT(COMM) FROM EMP

SELECT MIN(HIREDATE), MAX(HIREDATE) FROM EMP 

-- AGGREGATE FUNCTION WITH GROUP BY CLAUSE
-- GROUP LEVEL SUMMARY

-- TOTAL SAL FOR ORG
SELECT SUM(SAL) FROM EMP
-- PRINT DEPTWISE TOTAL SAL
SELECT DEPTNO, SUM(SAL) FROM EMP GROUP BY DEPTNO

-- FOR EACH DEPT PRINT HIGHEST AND LOWEST SAL
SELECT DEPTNO, MAX(SAL) MMAX, MIN(SAL) MMIN FROM EMP GROUP BY DEPTNO

-- LIST DEPTWISE, JOBWISE EMP COUNT
SELECT DEPTNO, JOB , COUNT(EMPNO) FROM EMP GROUP BY DEPTNO, JOB ORDER BY DEPTNO, JOB

-- deptwtise job count
-- LIST ONLY DEPT AND COUNT WHERE EMPCOUNT > 4
SELECT DEPTNO, COUNT(EMPNO) AS EMPCOUNT FROM EMP GROUP BY DEPTNO HAVING COUNT(EMPNO)> 4;

-- DISTINCT (UNIQUE VALUES)
-- LIST JOBS FROM EMP TABLE
SELECT DISTINcT JOB FROM EMP

-- TOP N
SELECT TOP 3 * FROM EMP
-- LIST TOP 3 HIGHEST PAID EMPLOYEE
SELECT TOP 3 WITH TIES * FROM EMP ORDER BY SAL DESC  -- WITH TIES RESOLVES TIES BY INCLUDING THEM

-- date function
SELECT GETDATE()

-- EXTRACT DATE PART FROM A DATE
SELECT GETDATE(), DATEPART(dd,GETDATE()) AS DAY
SELECT GETDATE(), DATEPART(MM,GETDATE()) AS MONTH, DATENAME(MM, GETDATE())
SELECT GETDATE(), DATEPART(yy,GETDATE()) AS DATEYEAR
SELECT GETDATE(), DATEPART(YYYY,GETDATE()) AS YEAR
SELECT GETDATE(), DATEPART(HH,GETDATE()) AS hour
SELECT GETDATE(), DATEPART(mi,GETDATE()) AS minute
SELECT GETDATE(), DATEPART(ss,GETDATE()) AS second

SELECT GETDATE(), DATEPART(dw,GETDATE()) AS dayofweek, datename(DW, GETDATE())
SELECT GETDATE(), DATEPART(ww,GETDATE()) AS WEEKOFTHEYEAR
SELECT GETDATE(), DATEPART(DAYOFYEAR, getdate()) AS dayoftheyear
select getdate(), datepart(Q,GETDATE())

SELECT DAY(GETDATE()),MONTH(GETDATE()), YEAR(GETDATE())

-- DATEADD AND DATEDIFF
SELECT GETDATE(), DATEADD(MM, 6, GETDATE()), DATEADD(DD,180,GETDATE()), DATEADD(MM,-6,GETDATE())
SELECT DATEDIFF(DD, '01/01/2021', GETDATE()), DATEDIFF(MM, '01/01/2021', GETDATE())

-- MSSQLTIPS.COM/SQLSERVERTIP/1145/DATE-AND-TIME-CONVERSIONS-USING-SQL-SERVER/
select GETDATE(), CONVERT(VARCHAR, GETDATE(), 1), CONVERT(VARCHAR, GETDATE(),101)
SELECT CONVERT(VARCHAR, GETDATE(), 130)

-- GLOBALIZATION - D/d N C
-- FORMAT()

--FORMAT - DATE(D), NUMBER(N), CURRENCY(C)
SELECT FORMAT(GETDATE(), 'd', 'en-US')

SELECT	FORMAT(GETDATE(), 'D', 'en-US') AS 'US ENGLISH',
		FORMAT(GETDATE(), 'D', 'DE-DE') AS 'GERMAN',
		FORMAT(GETDATE(), 'D', 'pa-IN') AS 'PUNJABI'
-- NUMBER FORMATSS
SELECT FORMAT(46498713216579,'N', 'EN-US') AS 'US', FORMAT(46498713216579,'N', 'HI-IN') AS 'IN'  -- 3, 2,
SELECT FORMAT(46498713216579,'C', 'EN-US') AS 'US', FORMAT(46498713216579,'C', 'HI-IN') AS 'IN' -- WITH $ & RS SIGN

-- NEMBER / MATHEMATICAL
SELECT ABS(-12)
SELECT CEILING(394.1)
SELECT ROUND(1245.55555,2) -- LEAVES TRAILNG ZEROES
SELECT FORMAT(134.6564, '0.00'), FORMAT(1256.56665, '0')  -- BETTER THAN ROUND
SELECT ROUND(1245.56789,0)
SELECT POWER(5,3)
SELECT PI()


--STRING
DECLARE @NAME CHAR(20)
SET @NAME='CHANDLER'

SELECT ENAME, LEN(ENAME) FROM EMP
SELECT UPPER('CHANDLER'), LOWER('CHANDLER')

SELECT REPLICATE('*', 10)
SELECT 'HELLO' +		'          WELCOME		' + 'TO SQL'
SELECT 'HELLO' + LTRIM(	'        WELCOME		') + 'TO SQL'
SELECT 'HELLO' + RTRIM(	'         WELCOME         ') + 'TO SQL'
SELECT 'HELLO' + RTRIM(LTRIM('       WELCOME       ')) + 'TO SQL'

SELECT LEFT('WELCOME', 3) --START
SELECT RIGHT('WELCOME', 3) --END

SELECT SUBSTRING('WELCOME', 3,3)
SELECT ASCII('A'), CHAR(65)
SELECT CONCAT('A','B','C')
SELECT 'A' + 'B' + 'C'
-- conditional check
select ENAME, COMM,
CASE	
	WHEN COMM = 0 THEN 'EARNING ZERO COMMISSION'
	WHEN COMM IS NULL THEN 'NOT EARNING COMMISSION'
	ELSE 'EARNING COMMISSION'
end as MSG
FROM EMP
ORDER BY COMM DESC

-- RANK FUNCTION
-- ROW_NUMBER
-- RANK
-- DENSE_RANK

SELECT ROW_NUMBER() OVER (ORDER BY SAL DESC) AS SRNO, 
	   RANK() OVER (ORDER BY SAL DESC) AS RNK,
	   DENSE_RANK()OVER (ORDER BY SAL DESC) AS DNSRNK,
* FROM EMP 


-------------------------

-------------------------date-------------------------------


--1		LIST empname, hiredate and the no of years completed by each employee in organization
SELECT ename, hiredate, DATEDIFF(YY, HIREDATE, GETDATE() ) AS YEARS_COMPLETED FROM EMP

--2		LIST ALL EMP WHO HAVE JOINED BEFORE 2000
SELECT * FROM EMP WHERE DATEPART(YY, HIREDATE)<2000

--3		LIST ALL EMP WHO HAVE COMPLETED 35 YEARS OF SERVICE
SELECT * FROM EMP WHERE DATEDIFF(YY, HIREDATE, GETDATE() ) >= 35

--4		LIST ALL EMP AS PER THE MONTH OF JOINING IRRESPECITVE OF THE YEARS . EXAMPLE JAN, FEB .... DEC
SELECT * FROM EMP ORDER BY DATEPART(MM, HIREDATE)

--5		LIST ALL EMP WHO HAVE JOINED IN DEC 81
SELECT * FROM EMP WHERE DATEPART(MM, HIREDATE)=12 AND DATEPART(YY, HIREDATE)=1981

--6		LIST EACH YEAR   IN WHICH ALL EMP HAVE JOINED
SELECT DISTINCT DATEPART(YY, HIREDATE) AS YEAR FROM EMP

--7		For each employee display the number of days passed since the employee joined the company
SELECT *, DATEDIFF(DD, HIREDATE, GETDATE() ) AS DAYS_COMPLETED FROM EMP

--8		list empname, hiredate and dayoftheweek when employee joined the organization
SELECT ename, hiredate, DATENAME(DW, HIREDATE) AS JOINING_DAY FROM EMP

--9		LIST THE YEAR AND TOTAL NO OF EMP JOINED IN THAT YEAR  
-- 1981		3
-- 1985		5
SELECT DATEPART(YY, HIREDATE), COUNT(EMPNO) FROM EMP GROUP BY DATEPART(YY, HIREDATE)

--10	LIST FULL DETAILS OF OLDEST  EMPLOYEE
SELECT TOP 1 * FROM EMP ORDER BY HIREDATE
--------------------------------------------------------------------------------

--11
--DISPLAY EMP NAME IN PROPER CASE
--Smith
--Allen
--Ward
SELECT (UPPER(LEFT(ENAME,1)) + LOWER(RIGHT(ENAME,LEN(ENAME)-1))) FROM EMP

--12
--All employees who are not receiving commission are 
--entitled  to Rs. 250 as an additional amount,  show the net earnings  of all employees
SELECT SAL+250 AS NET_EARNING FROM EMP WHERE COMM IS NULL
--13
 ---- Display the name, job and bonus for all employees, 
 --assuming all managers gets a bonus of Rs. 500, 
 --clerk gets Rs. 200 
 --and all other except president get Rs. 350. 
 --The president gets 20% of his salary as bonus
select ENAME, JOB,
CASE	
	WHEN JOB='MANAGER' THEN 500
	WHEN JOB='CLERK' THEN 200
	WHEN JOB='PRESIDENT' THEN 350	
	ELSE 0.2 * SAL
end as BONUS
FROM EMP
 
 --------------------------------
--14	 Find the  job of the employees receiving commission
SELECT JOB FROM EMP WHERE COMM IS NOT NULL
 
--15	 Show the daily salary of all employees assuming a month has 30 days without any decimal
SELECT FORMAT(SAL/30, '0') AS DAILYSAL FROM EMP;
 
--16	display record of last joined employee
SELECT TOP 1 * FROM EMP ORDER BY HIREDATE DESC

--17	list empname, hiredate, sal , comm and netsal in date, number and currency format of India
SELECT	ENAME, 
		FORMAT(HIREDATE, 'D', 'hi-IN') AS HIREDATEIND, 
		FORMAT(SAL, 'C', 'hi-IN') AS INRSAL, 
		FORMAT(COMM,'C', 'hi-IN') AS COMM, 
		FORMAT(ISNULL(SAL,0)+ISNULL(COMM ,0), 'C', 'hi-IN') AS NETSALARY 
FROM EMP

--18	show empoyee data as per year or joing
--		for each year jan to dec give sr no 1, 2, ...
--		year change again start number for 1
SELECT *, DENSE_RANK() OVER (ORDER BY DATEPART(MM,HIREDATE)) AS MNTHRNK, DATEPART(YY,HIREDATE) AS YEARR, AVG(SAL) OVER(PARTITION BY DATEPART(YY,HIREDATE)) AS SALARY FROM EMP 

--19	CASE SENSITIVE
-- IN MS SQL SERVER HOW TO WORK ON CASE SENSITIVE DATA
-- SELECT SERVERPROPERTY('COLLATION')
select * FROM EMP WHERE ENAME LIKE 'KINg' COLLATE SQL_Latin1_General_CP1_CS_AS
---------------------------------------------


------- ADVANCE QUERY ---------
-- LIST ALL EMP WHO ARE WORKING IN SAME DEPT WITH MARTIN
SELECT * FROM EMP WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME = 'MARTIN')

--1		list all emp whose designation is same as BLAKE
SELECT * FROM EMP WHERE JOB IN (SELECT JOB FROM EMP WHERE ENAME = 'BLAKE')

--2		list all emp who are earning more then the average salary of the organization
SELECT * FROM EMP WHERE SAL > (SELECT AVG(SAL) FROM EMP)

--3		list full detail (all column of emp table) of highest paid employee (without using Top n)
SELECT * FROM EMP WHERE SAL=(SELECT MAX(SAL) FROM EMP)
--4		list all emp whose sal is more then Allen and working
--in same deparment with Scott and 
--hireed in same year of Jones
SELECT * FROM EMP WHERE 
	SAL > (SELECT SAL FROM EMP WHERE ENAME='ALLEN') AND 
	DEPTNO IN (SELECT DEPTNO FROM EMP WHERE ENAME='SCOTT') AND 
	DATEPART(YY, HIREDATE)=(SELECT DATEPART(YY, HIREDATE) FROM EMP WHERE ENAME='JONES')

--5		list all emp whose manager is king
SELECT * FROM EMP WHERE MGR IN (SELECT EMPNO FROM EMP WHERE ENAME='KING')

--6		LIST ALL EMP WHOSE MANAGER'S MANGER IS KING
SELECT * FROM EMP WHERE MGR IN (SELECT EMPNO FROM EMP WHERE MGR IN (SELECT EMPNO FROM EMP WHERE ENAME='KING'))

--7		list all emp who are working in research department
SELECT * FROM EMP WHERE DEPTNO=(SELECT DEPTNO from DEPT WHERE DNAME='RESEARCH')

--8		list all emp who are working in NEW YORK
SELECT * FROM EMP WHERE DEPTNO IN (SELECT DISTINCT DEPTNO FROM DEPT WHERE LOC='NEW YORK')
--SELECT * FROM DEPT 

--9		print department name where all emps are earning commission
SELECT DNAME FROM DEPT WHERE DEPTNO NOT IN (SELECT DISTINCT DEPTNO FROM EMP WHERE COMM IS NULL)
-- print department name where emps are earning commission
SELECT DNAME FROM DEPT WHERE DEPTNO IN (SELECT DEPTNO FROM EMP WHERE COMM IS not NULL)

select * FROM EMP order by deptno

--10		LIST ALL EMP WHO ARE WORKING IN BOSTON AND EARNING MORE THEN THE AVERAGE OF DEPT LOCATED IN BOSTON
SELECT * FROM EMP WHERE DEPTNO IN (SELECT DEPTNO FROM DEPT WHERE LOC='BOSTON') AND 
	SAL > (SELECT AVG(SAL) FROM EMP WHERE DEPTNO IN (SELECT DEPTNO FROM DEPT WHERE LOC='BOSTON'))

-- JOINS - SELECT COLUMNS FROM TWO DIFFERENT TABLES

SELECT * FROM EMP, DEPT  -- CARTESIAN PRODUCT OR CROSS JOIN
-- ALWAYS WRITE JOIN CONDITON
SELECT E.ENAME, E.JOB, E.SAL, D.DNAME, D.LOC FROM EMP E JOIN DEPT D ON E.DEPTNO=D.DEPTNO -- INNERJOIN / EQUI JOIN inner keyword is optional

SELECT E.ENAME, E.JOB, E.SAL, D.DNAME, D.LOC FROM EMP E LEFT OUTER JOIN DEPT D ON E.DEPTNO=D.DEPTNO

-- DEPTNAME AND EMPCOUNT FOR EACH DEPT
SELECT D.DNAME, COUNT(EMPNO) FROM EMP E JOIN DEPT D ON  E.DEPTNO=D.DEPTNO GROUP BY D.DNAME
SELECT D.DNAME, COUNT(EMPNO) FROM EMP E RIGHT JOIN DEPT D ON  E.DEPTNO=D.DEPTNO GROUP BY D.DNAME

-- list PRODUCT NAME, PRICE AND CATEGORY NAME
--ALTER TABLE PRODUCT MODIFY COLUMN PRODUCTNAMENAME PRODUCTNAME
SELECT P.PRODUCTNAME, P.PRICE, C.CATEGORYNAME FROM PRODUCT P JOIN CATEGORY C ON P.CATEGORYID=C.CATEGORYID

-- LIST EMPNAME, JOB, SAL, DEPTNAME, LOC OF LOWEST PAID EMPLOYEE (NO TOP N)
--SELECT ENAME, JOB, SAL, DNAME, LOC FROM EMP WHERE sal = ()

--SELF JOIN
SELECT E.ENAME AS EMPNAME, E.JOB, E.SAL, M.ENAME AS MGRNAME FROM EMP E JOIN EMP M ON E.MGR=M.EMPNO ORDER BY E.MGR
SELECT E.ENAME AS EMPNAME, E.JOB, E.SAL, M.ENAME AS MGRNAME FROM EMP E LEFT JOIN EMP M ON E.MGR=M.EMPNO ORDER BY E.MGR
select E.*, M.* FROM DEPT E JOIN DEPT M ON E.DEPTNO=M.DEPTNO

-- LIST ENAME, JOB, SAL, DNAME, MGRNAME, LOC FOR ALL EMPS
--SELECT E.ENAME, E.JOB, E.SAL, D.DNAME, D.LOC  FROM EMP E JOIN DEPT D ON E.DEPTNO=D.DEPTNO
SELECT * FROM EMP 
SELECT E.ENAME, E.JOB, E.SAL, D.DNAME, D.LOC, M.ENAME AS MGRNAME  FROM EMP E JOIN EMP M ON E.EMPNO=M.MGR JOIN DEPT D ON E.DEPTNO=D.DEPTNO
SELECT E.ENAME, E.JOB, E.SAL, D.DNAME, D.LOC, M.ENAME FROM EMP E JOIN DEPT D ON E.DEPTNO=D.DEPTNO JOIN EMP M ON E.MGR=M.EMPNO


--WINDOWS NULL
--UNIX	NULL
--IOS NULL
--MSOFFICE WINDOWS
--SS LINUX
--ITUNE IOS


--SELECT P.PROGNAME, Q.PROGNAME FROM PROGRAM P RIGHT JOIN PROGRAM Q ON P.PROGID=Q.OS

------------------------------SUB QUERY AND JOINS FOR ASSIGNMENT TABLES---------------------------------

--1	LIST COSTLIEST PRODUCT DETAILS
SELECT * FROM PRODUCT WHERE PRICE = (SELECT MAX(PRICE) FROM PRODUCT)

--2	PRINT ALL THE ORDERS PLACED BY CUSTOMER AJAY
SELECT O.* FROM ORDERS O JOIN CUSTOMER C ON O.CUSTOMERID=C.CUSTOMERID WHERE C.CUSTOMERNAME='AJAY'
--SELECT * FROM ORDERS
--SELECT * FROM CUSTOMER

--3	LIST PRODUCTNAME, PRICE, QUANTITY AND CATEGORYNAME
--SELECT * FROM PRODUCT
--SELECT * FROM CATEGORY
SELECT P.PRODUCTNAME, P.PRICE, P.QUANTITY, C.CATEGORYNAME FROM PRODUCT P JOIN CATEGORY C ON P.CATEGORYID=C.CATEGORYID

--4	LIST ORDERYEAR, ORDERMONTH, ORDERID, ORDERDATE, CUSTOMERNAME FOR ALL ORDERS
--SELECT * FROM ORDERS
--SELECT * FROM CUSTOMER
SELECT O.ORDERYEAR, O.ORDERMONTH, O.ORDERID, O.ORDERDATE, C.CUSTOMERNAME FROM ORDERS O JOIN CUSTOMER C ON O.CUSTOMERID=C.CUSTOMERID

--5	LIST ALL THE ORDERS FOR THE CATEGORY ELECTRONICS
--SELECT * FROM ORDERS
--SELECT * FROM PRODUCT
--SELECT * FROM CATEGORY
SELECT * FROM ORDERS WHERE PRODUCTID IN (SELECT PRODUCTID FROM PRODUCT WHERE CATEGORYID  = (SELECT CATEGORYID FROM CATEGORY WHERE CATEGORYNAME='ELECTRONICS'))

--6	LIST ALL THE ORDERS WHOSE PRICE IS GREATER THEN 1000
SELECT * FROM ORDERS WHERE PRODUCTID IN (SELECT PRODUCTID FROM PRODUCT WHERE PRICE>1000)

--7	LIST ALL THE ORDERS FOR THE CUSTOMER CHIRAG PLACED FOR CATEGORY FOOD
SELECT * FROM ORDERS
SELECT * FROM CUSTOMER
SELECT * FROM CATEGORY
SELECT * FROM PRODUCT
SELECT O.* FROM ORDERS O JOIN CUSTOMER CST ON O.CUSTOMERID=CST.CUSTOMERID JOIN PRODUCT P ON O.PRODUCTID=P.PRODUCTID WHERE P.CATEGORYID=(SELECT CATEGORYID FROM CATEGORY WHERE CATEGORYNAME='FOOD') AND CST.CUSTOMERNAME='CHIRAG'


--8	LIST ORDERYEAR, ORDERMONTH, ORDERID, ORDERDATE, CUSTOMERNAME, 
--	CATEGORYNAME, PRODUCTNAME, PRICE, ORDERQTY, TOTAL(PRICE*ORDERQTY) FOR ALL ORDERS
SELECT O.ORDERYEAR, O.ORDERMONTH, O.ORDERID, O.ORDERDATE, CST.CUSTOMERNAME,C.CATEGORYNAME, P.PRODUCTNAME, P.PRICE, P.QUANTITY, P.PRICE*P.QUANTITY AS TOTAL 
FROM ORDERS O JOIN CUSTOMER CST ON O.CUSTOMERID=CST.CUSTOMERID JOIN PRODUCT P ON O.PRODUCTID=P.PRODUCTID JOIN CATEGORY C ON P.CATEGORYID=C.CATEGORYID


--9	LIST TOTAL ORDERCOUNT, TOTALORDERQTY, TOTALVALUE OF ORDERS PLACE BY CUSTOMER AJAY

--	HINT: BELOW OUTPUT
--ORDERCOUNT	TOTALORDERQTY	TOTALVALUE
--3					9				620.00
SELECT COUNT(O.ORDERID) AS ORDERCOUNT, SUM(O.ORDQRY) AS TOTALORDERQTY, SUM(P.PRICE) AS TOTALVALUE FROM ORDERS O JOIN CUSTOMER CST ON O.CUSTOMERID=CST.CUSTOMERID JOIN PRODUCT P ON P.PRODUCTID=O.PRODUCTID WHERE CST.CUSTOMERNAME='AJAY'

--10	LIST SUM OF  ORDERQTY  FROM ORDERS TABLE FOR CATEGORY ELECTRONICS 
SELECT SUM(ORDQRY) FROM ORDERS O JOIN PRODUCT P ON O.PRODUCTID=P.PRODUCTID JOIN CATEGORY C ON P.CATEGORYID=C.CATEGORYID WHERE C.CATEGORYNAME='ELECTRONICS'
--HINT
--TOTALORDERQTY
--2

--11	PRINT RECORD OF 3RD HIGHEST SALARY EARNED EMPLOYEE  (DO NOT USE TOP N)
SELECT * FROM (SELECT *,DENSE_RANK() OVER (ORDER BY	SAL DESC) AS R FROM EMP) AS T WHERE R=3
SELECT * FROM EMP WHERE SAL=(SELECT MAX(SAL) FROM EMP WHERE SAL<(select max(sal) FROM EMP WHERE SAL != (SELECT MAX(SAL) FROM EMP)))
-- correlated subquery
SELECT * FROM EMP E1 WHERE (3) = (SELECT COUNT(DISTINCT (E2.SAL)) FROM EMP E2 WHERE E2.SAL >= E1.SAL)

-- TEMP DATABASE
-- CTE COMMON TABLE EXPRESSION
-- TABLE VARIABLE  -- REAL WORLD EXAMPLE


-- TSQL-------------
PRINT 'HELLO'
PRINT 100
GO
PRINT 'HELLO - ' + CONVERT(VARCHAR, 100)
PRINT 'HELLO - ' + CAST(100 AS VARCHAR)

-- PRINT TODAY'S DATE
PRINT CAST(GETDATE() AS VARCHAR)
PRINT CONVERT(VARCHAR, GETDATE(), 1)



-- TAKE NAME FROM USER AND GREET
-- LOCAL VARIABLE
DECLARE @NAME VARCHAR(100)
SET @NAME='CHRIS'
PRINT 'HELLO ' + @NAME
SELECT @NAME=ENAME FROM EMP WHERE EMPNO=7902
PRINT 'HELLO ' + @NAME

--GLOBAL VARIABLE
SELECT @@VERSION
DECLARE @@UGLOB VARCHAR(100)
SET @@UGLOB = 'MAX'
PRINT @@UGLOB

-- CONDITIONAL CHECK
-- ODD EVEN
DECLARE @N INT
SET @N=9
IF @N%2=0
	PRINT 'EVEN'
ELSE
	PRINT 'ODD'

DECLARE @EMPNO INT
DECLARE @ENAME VARCHAR (20)
DECLARE @JOB VARCHAR (20)
DECLARE @SAL NUMERIC

SET @EMPNO=7999
IF @EMPNO IN (SELECT EMPNO FROM EMP)
BEGIN
	(SELECT @ENAME=ENAME, @JOB=JOB, @SAL=SAL FROM EMP WHERE EMPNO=@EMPNO)
	PRINT CONVERT(VARCHAR, @EMPNO) +  @ENAME +  @JOB + CONVERT(VARCHAR, @SAL)
END
ELSE
	PRINT 'EMP NOT FOUND'

-- LOOOP
DECLARE @N INT
SET @N=10
WHILE @N>0
BEGIN
	PRINT @N
	SET @N=@N-1
END

SELECT * FROM SYSMESSAGES

-- TRY CATCH
BEGIN TRY
	SELECT 1/0
END TRY
BEGIN CATCH
	PRINT 'ERROR'
	-- execute the error retrieval statement
	SELECT
		--ERROR_NUMBER(), ERROR_SEVERITY(), ERROR_STATE(), ERROR_PROCEDURE(), ERROR_LINE(), ERROR_MESSAGE()
		--RAISERROR(MSG_STR, SEVERITY, STATE)
		--RAISERROR ('NUMBER CANNOT BE DIVIDED BY ZERO', 16,1)
		--RAISERROR(ERROR_MESSAGE(), ERROR_SEVERITY(), ERROR_STATE())
		--THROW 50001, 'NUMBER CANNOT BE DIVIDED BY ZERO'
END CATCH

-- STORED PROCEDURE
CREATE PROCEDURE ODDEVENCHECK (@N INT) AS
BEGIN
	IF @N%2=0
		PRINT 'EVEN'
	ELSE
		PRINT 'ODD'
END

EXEC ODDEVENCHECK 3
EXEC ODDEVENCHECK 4

-- PROCEDURE TO ALL EMP DATA
CREATE PROC EMPPROCEDURE AS
	SELECT * FROM EMP

EXEC EMPPROCEDURE

-- WRITE A PROC WHICH TAKE EMPNO AS A PARAM
-- PRINT EMP RECORD AS BELOW
-- WARD IS WORKING AS SALESMAN IN DEPT 30
CREATE PROC JOBDESC(@N AS INT) AS
BEGIN
	DECLARE @NAME VARCHAR(80), @JOB VARCHAR(80), @DEPT INT
	SELECT @NAME=E.ENAME, @JOB=E.JOB, @DEPT=E.DEPTNO FROM EMP E WHERE EMPNO=@N --JOIN DEPT D ON E.DEPTNO=D.DEPTNO WHERE E.EMPNO=@N
	PRINT @NAME + ' IS WORKING AS ' + @JOB + ' IN DEPT ' + CAST(@DEPT AS VARCHAR) 
END

ALTER PROC JOBDESC(@N AS INT) AS
BEGIN
	DECLARE @NAME VARCHAR(80), @JOB VARCHAR(80), @DEPT INT, @COUNT INT
	SELECT @NAME=ENAME, @JOB=JOB, @DEPT=DEPTNO FROM EMP WHERE EMPNO=@N --JOIN DEPT D ON E.DEPTNO=D.DEPTNO WHERE E.EMPNO=@N
	SET @COUNT = @@ROWCOUNT
	PRINT @COUNT
	IF @COUNT = 0
		RAISERROR ('EMPLOYEE NOT FOUND',16,1)
	ELSE		
		PRINT @NAME + ' IS WORKING AS ' + @JOB + ' IN DEPT ' + CAST(@DEPT AS VARCHAR) 
END

EXEC JOBDESC 7901

/*
--TAKE MGRNO AS PARAMETER


--PRINT MESSAGE AS BELOW

TOTAL EMPLOYEE WORKING UNDER _____MGRNAME__________ = 4

IF NOT FOUND PRINT HE IS NOT A MANAGER

*/


SELECT COUNT(E.EMPNO) FROM EMP E JOIN EMP M ON E.MGR=M.EMPNO WHERE E.MGR=7566

CREATE PROC EMPUNDERMGR(@MGRNO AS INT) AS
BEGIN
	DECLARE @MGRNAME VARCHAR(80), @COUNT INT
	
	SELECT @MGRNAME=M.ENAME FROM EMP E JOIN EMP M ON E.MGR=M.EMPNO WHERE E.MGR=7566
	SET @COUNT = @@ROWCOUNT
	PRINT @COUNT
	IF @COUNT = 0
		RAISERROR ('NOT A MANAGER',16,1)
	ELSE		
		PRINT 'TOTAL EMPLOYEE WORKING UNDER ' + @MGRNAME + ' = ' + CAST(@COUNT AS VARCHAR)
END

EXEC EMPUNDERMGR 7901


-- cursor
ALTER PROC EMPUNDERMGR(@ENO AS INT) AS
BEGIN
	DECLARE @EMPCOUNT INT, @MGRNAME VARCHAR(80), @COUNT INT, @EMPNAME VARCHAR(80), @ROWCOUNT INT
	SELECT @MGRNAME=ENAME FROM EMP WHERE EMPNO=@ENO
	SET @ROWCOUNT = @@ROWCOUNT
	IF @ROWCOUNT > 0
	BEGIN
		SELECT @EMPCOUNT=COUNT(EMPNO) FROM EMP WHERE MGR=@ENO
		IF @EMPCOUNT=0
			PRINT 'NO EMPLOYEE IS REPORTING TO ' + @MGRNAME
		ELSE
		BEGIN	
			PRINT 'TOTAL EMPLOYEE REPORTING TO ' + @MGRNAME + ' = ' + CAST(@EMPCOUNT AS VARCHAR)
			DECLARE MGR_CURSOR CURSOR FOR SELECT E.ENAME FROM EMP E JOIN EMP M ON E.MGR=M.EMPNO WHERE M.EMPNO=@ENO
			OPEN MGR_CURSOR
			FETCH NEXT FROM MGR_CURSOR INTO @EMPNAME
			WHILE @@FETCH_STATUS=0
			BEGIN
				PRINT 'EMPNAME: ' + @EMPNAME
				FETCH NEXT FROM MGR_CURSOR INTO @EMPNAME
			END
			CLOSE MGR_CURSOR
			DEALLOCATE MGR_CURSOR
		END
	END
	ELSE 
		RAISERROR ('EMPLOYEE NOT FOUND',16,1)
END

EXEC EMPUNDERMGR 7902

-- TAKE DEPTNO AS PARAMETER AND FOR THAT DEPT RETURN MINSAL, MAXSAL AND EMPCOUNT
CREATE PROC OUTPARAMDEMO (@DNO INT, @MINSAL NUMERIC(10,2) OUT, @MAXSAL NUMERIC(10,2) OUT, @COUNT INT OUT) AS
BEGIN 
	SELECT @MINSAL = MIN(SAL), @MAXSAL=MAX(SAL), @COUNT=COUNT(EMPNO) FROM EMP WHERE DEPTNO=@DNO
END

DECLARE @MINSAL NUMERIC(10,2), @MAXSAL NUMERIC(10,2), @COUNT INT
EXEC OUTPARAMDEMO 10, @MINSAL OUT, @MAXSAL OUT, @COUNT OUT
PRINT 'MINSAL = ' + CAST(@MINSAL AS VARCHAR) + CHAR(13) + 'MAXSAL = ' + CAST(@MAXSAL AS VARCHAR) + CHAR(13) + 'COUNT = ' + CAST(@COUNT AS VARCHAR)	

-- CHANGE IN SAME PROC
-- INSTEAD OF DEPTNO USE DEPTNAME
ALTER PROC OUTPARAMDEMO (@DNAME VARCHAR(80), @MINSAL NUMERIC(10,2) OUT, @MAXSAL NUMERIC(10,2) OUT, @COUNT INT OUT) AS
BEGIN 
	--SELECT @MINSAL = MIN(SAL), @MAXSAL=MAX(SAL), @COUNT=COUNT(EMPNO) FROM EMP WHERE DEPTNO=@DNO
	SELECT  @MINSAL = MIN(E.SAL), @MAXSAL=MAX(E.SAL), @COUNT=COUNT(E.EMPNO) FROM EMP E JOIN DEPT D ON E.DEPTNO=D.DEPTNO WHERE D.DNAME=@DNAME
END
DECLARE @MINSAL NUMERIC(10,2), @MAXSAL NUMERIC(10,2), @COUNT INT, @DNAME VARCHAR(80)
DECLARE @DNAME VARCHAR(80)
EXEC OUTPARAMDEMO 'SALES', @MINSAL OUT, @MAXSAL OUT, @COUNT OUT

--PROC WITH DML
--INSERT PROC
--WRITE A PROC WHICH TAKES EMPNO, EMPNAME AND DEPTNO AS A PARAMETER 
--INSERT VALUE IN EMP TABLE
--IF INSERTED SUCESSFULY PASS MESSAGE  OR ERROR MESSAGE IN OUT PARAMETER
CREATE PROC INS(@ENO INT, @ENAME VARCHAR(80), @DEPTNO INT, @STATUS VARCHAR OUT) AS
BEGIN
	BEGIN TRY
		INSERT INTO EMP(EMPNO, ENAME, DEPTNO) VALUES(@ENO, @ENAME, @DEPTNO)
		SET @STATUS='INSERTED'
	END TRY
	BEGIN CATCH
		SET @STATUS='FAILED'
	END CATCH
END

--DELETE PROC
--TAKE EMPNO FROM USER
--IF FOUND DELETE THE RECORD
--IF DELETEDSUCESSFULY PASS MESSAGE  OR ERROR MESSAGE IN OUT PARAMETER

CREATE PROC DEL(@ENO INT, @STATUS VARCHAR OUT) AS
BEGIN
	BEGIN TRY
		DELETE FROM EMP WHERE EMPNO=@ENO
		SET @STATUS='DELETED'
	END TRY
	BEGIN CATCH
		SET @STATUS = 'FAILED'
	END CATCH
END

-- AUTO MODE - EACH 
--select * FROM EMP FRO XML PATH

SELECT EMPNO, ENAME, JOB, SAL FROM EMP WHERE EMPNO IN (7902, 7839, 7566) FOR XML PATH('EMPROW'), ROOT('EMPLOYEES')

DELETE FROM EMP WHERE SAL<7000
SELECT * FROM EMP
CREATE PROCEDURE ParseXMLTOTABLE @INPUTXML XML AS
BEGIN
	INSERT INTO EMP (EMPNO, ENAME, SAL)
	SELECT
		RESULTS.EMPLOYEELIST.value('EMPNO[1]', 'INT') AS EMPNO,  -- XML is case sensitive
		RESULTS.EMPLOYEELIST.value('EMPNAME[1]', 'NVARCHAR(20)') AS EMPNAME,
		RESULTS.EMPLOYEELIST.value('SALARY[1]', 'NUMERIC(10,2)') AS SALARY
		FROM @InputXML.nodes('EMPLOYEELIST/EMPLOYEE') RESULTS(EMPLOYEELIST)
		SELECT * FROM EMP
END

DECLARE @FileXML XML = '
 <EMPLOYEELIST>
   <EMPLOYEE>
     <EMPNO>1</EMPNO>	 
     <EMPNAME>BHAVANA</EMPNAME>     
     <SALARY>4000</SALARY>
   </EMPLOYEE>
   <EMPLOYEE>
     <EMPNO>2</EMPNO>
     <EMPNAME>VISHAL</EMPNAME>     
     <SALARY>3000</SALARY>
   </EMPLOYEE>  
 </EMPLOYEELIST>'
exec ParseXMLTOTable @FileXML

CREATE PROCEDURE PARSETABLETOXML @OUTPUTXML XML OUT AS
BEGIN 
	SET @OUTPUTXML = (SELECT EMPNO, ENAME, SAL FROM EMP FOR XML PATH('EMPLOYEE'), ROOT('EMPLOYEELIST'))
END
DECLARE @Output_XML XML
EXEC ParseTableToXML @Output_XML OUT
SELECT @Output_XML


--TEMPDB
--CTE
--TABLE VARIABLE

-------------
--SP

--COMMA SEPRATED EMP NAME BASED ON DEPTNO
--SELECT * FROM EMP
ALTER PROC DEPTEMPS(@DNO AS INT, @EMPLIST AS VARCHAR(MAX) OUT) AS
BEGIN
	DECLARE @EMPNAME VARCHAR(80)
	DECLARE ENAME_CSR CURSOR FOR SELECT ENAME FROM EMP WHERE DEPTNO=@DNO
	OPEN ENAME_CSR
	FETCH NEXT FROM ENAME_CSR INTO @EMPNAME
	WHILE @@FETCH_STATUS=0
	BEGIN
		--PRINT 'EMPNAME: ' + @EMPNAME
		IF @EMPLIST IS NULL
			SET @EMPLIST=@EMPNAME
		ELSE
			SET @EMPLIST = @EMPLIST + ', ' + @EMPNAME
		--PRINT @EMPLIST
		FETCH NEXT FROM ENAME_CSR INTO @EMPNAME
	END
	CLOSE ENAME_CSR
	DEALLOCATE ENAME_CSR
END
DECLARE @ELIST VARCHAR(MAX)
EXEC DEPTEMPS 10, @ELIST OUT
PRINT @ELIST

-------------------
--SP

--CREATE TABLE EMPDATA1 (
--EMPNO INT IDENTITY PRIMARY KEY,
--EMPNAME VARCHAR(20),
--DEPTNO INT
--)



ALTER PROC INSEMPS(@DNO AS INT, @EMPLIST AS VARCHAR(MAX)) AS
BEGIN
	DECLARE @ENAME VARCHAR(80)
	--SET @ENO=1
	WHILE LEN(@EMPLIST)>0
	BEGIN
		SET @ENAME=LEFT(@EMPLIST, CHARINDEX(',', @EMPLIST+',')-1)
		INSERT INTO EMPDATA1(DEPTNO, EMPNAME) VALUES( @DNO, @ENAME)
		SET @EMPLIST = STUFF(@EMPLIST, 1, CHARINDEX(',', @EMPLIST+','), '')
	END
END
--CALL PROCEDURE AND PASS COMMA SEPRATED EMPNAME
--INSERT ALL EMP IN A TABLE AS INDEPENDENT RECORD

DECLARE @NAMELIST VARCHAR(50) = 'SMITH,JONES,KING,FORD'
EXEC INSEMPS 10, @NAMELIST
SELECT * FROM EMPDATA1

-- FUNCTION
CREATE FUNCTION CUBES(@NUM INT) RETURNS INT AS 
BEGIN
	RETURN @NUM * @NUM * @NUM
END

SELECT DBO.CUBES(5)

-- TAKE EMPNO AS PARAM AND RETURN NETSAL OF EMP
CREATE FUNCTION NETSAL(@ENO AS INT) RETURNS FLOAT AS
BEGIN
	DECLARE @NETSAL FLOAT
	SELECT @NETSAL=SAL FROM EMP WHERE EMPNO=@ENO
	RETURN @NETSAL
END

SELECT DBO.NETSAL(7999)

-- CREATE FUNCTION AS PROPERNAME TAKE VARCHAR AS PARAM AND RETURN VALUE IN PROPER CASE
CREATE FUNCTION PROPERCASE(@TXT VARCHAR(80)) RETURNS VARCHAR(80) AS
BEGIN
	SELECT @TXT=(UPPER(LEFT(@TXT,1)) + LOWER(RIGHT(@TXT,LEN(@TXT)-1)))
	RETURN @TXT
END
SELECT DBO.PROPERCASE('CHANDLER')

CREATE FUNCTION DEF(@A INT=10) RETURNS INT AS  --  DEFAULT VALUES ??
BEGIN	
	RETURN @A
END
SELECT DBO.DEF(NULL)
CREATE FUNCTION DEPTFUNCTION (@DNO INT) RETURNS TABLE AS 
	RETURN (SELECT ENAME, JOB, DEPTNO FROM EMP WHERE EMP.DEPTNO=@DNO)
GO
SELECT * FROM DEPTFUNCTION(30)

CREATE FUNCTION EMPSALDETAIL(@ENO INT) RETURNS @TABLE_VAR TABLE
(
	EMPNAME VARCHAR(20),
	SALARY NUMERIC(7,2),
	COMM NUMERIC(7,2),
	NETSAL NUMERIC(7,2)
) AS 
BEGIN
	INSERT INTO @TABLE_VAR SELECT ENAME, SAL, COMM, ISNULL(SAL,0)+ISNULL(COMM,0) FROM EMP WHERE EMPNO=@ENO
	RETURN
END


-- TRANSACTION
CREATE TABLE HDFC (
	H_ACCNO VARCHAR(10) PRIMARY KEY,
	H_BALANCE NUMERIC(7,2)
)
INSERT INTO HDFC VALUES('H101', 0);
CREATE TABLE SBI (
	S_ACCNO VARCHAR(10) PRIMARY KEY,
	S_BALANCE NUMERIC(7,2)
)
INSERT INTO SBI VALUES('S201', 30000)
SELECT * FROM HDFC
SELECT * FROM SBI

CREATE PROCEDURE VARIFYACCNO(@ACCNO VARCHAR (10), @MSG CHAR(1) OUT) AS
BEGIN
	DECLARE @ACC VARCHAR (10)
	SELECT ACC=S_ACCNO FROM SBI WHERE S_ACCNO=@ACCNO;
	IF @@ROWCOUNT=1
		SETMSG='Y'
	ELSE
		SET @MSG='N'
END
--ASSIGNMENT	-CALL PROCEDURE AND TEST THE REPLY
CREATE FUNCTION CHECKBALANCE (@FROM_ACCNO VARCHAR(10), @AMOUNT NUMERIC(7,2))
RETURNS NUMERIC (7, 2) AS
BEGIN
	DECLARE @BAL NUMERIC(7,2)=-1
	SELECT @BAL= (S_BALANCE - @AMOUNT) FROM SBI WHERE S_ACCNO=@FROM_ACCNO
	RETURN @BAL
END